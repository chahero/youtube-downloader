<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Downloader</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <div class="app-header">
            ğŸ¥ YouTube Downloader
            <div class="user-status">
                <span>{{ username if username else 'User' }}</span>
                {% if is_admin %}
                <a href="{{ url_for('admin_dashboard') }}">ğŸ‘¨â€ğŸ’¼ Admin</a>
                {% endif %}
                <a href="{{ url_for('logout') }}">Logout</a>
            </div>
        </div>

        <div class="input-section">
            <input type="text" id="url" placeholder="YouTube URL ì…ë ¥">

            <div class="options-row">
                <div class="option-group">
                    <label for="quality">í™”ì§ˆ:</label>
                    <select id="quality">
                        <option value="best">Best</option>
                        <option value="2160p">2160p (4K)</option>
                        <option value="1440p">1440p (2K)</option>
                        <option value="1080p" selected>1080p (Full HD)</option>
                        <option value="720p">720p (HD)</option>
                        <option value="480p">480p</option>
                        <option value="360p">360p</option>
                    </select>
                </div>

                <div class="option-group">
                    <label for="format">í¬ë§·:</label>
                    <select id="format">
                        <option value="video">Video (MP4)</option>
                        <option value="audio_mp3">Audio Only (MP3)</option>
                        <option value="audio_m4a">Audio Only (M4A)</option>
                    </select>
                </div>
            </div>

            <button onclick="startDownload()">ë‹¤ìš´ë¡œë“œ ì‹œì‘</button>
        </div>

        <!-- í•„í„° ë° ê²€ìƒ‰ -->
        <div class="filter-section">
            <div class="filter-buttons">
                <button class="filter-btn active" data-filter="all" onclick="setFilter('all')">ì „ì²´</button>
                <button class="filter-btn" data-filter="active" onclick="setFilter('active')">ì§„í–‰ì¤‘</button>
                <button class="filter-btn" data-filter="completed" onclick="setFilter('completed')">ì™„ë£Œ</button>
            </div>
            <div class="search-and-actions">
                <input type="text" id="search-input" placeholder="ê²€ìƒ‰..." onkeypress="if(event.key==='Enter')loadDownloads()">
                <button class="search-btn" onclick="loadDownloads()">ğŸ”</button>
                <button class="cleanup-btn" onclick="cleanupDownloads()">ğŸ§¹ ì •ë¦¬</button>
            </div>
        </div>

        <!-- ìƒíƒœ ì •ë³´ -->
        <div class="info">
            <span id="status-info">ì „ì²´: 0ê±´</span>
        </div>

        <!-- ë‹¤ìš´ë¡œë“œ ëª©ë¡ -->
        <div id="download-list"></div>

        <!-- í˜ì´ì§€ë„¤ì´ì…˜ -->
        <div id="pagination" class="pagination"></div>
    </div>

    <script>
        let currentFilter = 'all';
        let currentPage = 1;
        let refreshInterval = null;

        // í˜ì´ì§€ ë¡œë“œ ì‹œ
        document.addEventListener('DOMContentLoaded', function() {
            loadDownloads();
            // 3ì´ˆë§ˆë‹¤ ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ì§„í–‰ ì¤‘ì¸ ë‹¤ìš´ë¡œë“œ ìƒíƒœ ì—…ë°ì´íŠ¸)
            refreshInterval = setInterval(() => {
                if (currentFilter !== 'completed') {
                    loadDownloads(false);
                }
            }, 2000);
        });

        // í¬ë§· ì„ íƒ ì‹œ í™”ì§ˆ ì˜µì…˜ ë¹„í™œì„±í™”/í™œì„±í™”
        document.getElementById('format').addEventListener('change', function() {
            const qualitySelect = document.getElementById('quality');
            if (this.value.startsWith('audio_')) {
                qualitySelect.disabled = true;
                qualitySelect.style.opacity = '0.5';
            } else {
                qualitySelect.disabled = false;
                qualitySelect.style.opacity = '1';
            }
        });

        function setFilter(filter) {
            currentFilter = filter;
            currentPage = 1;

            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });

            loadDownloads();
        }

        async function loadDownloads(showLoading = true) {
            const search = document.getElementById('search-input').value.trim();

            try {
                let url = `/api/downloads?status=${currentFilter}&page=${currentPage}&per_page=10`;
                if (search) {
                    url += `&q=${encodeURIComponent(search)}`;
                }

                const response = await fetch(url);
                const data = await response.json();

                if (!response.ok) {
                    console.error('Error:', data.error);
                    return;
                }

                renderDownloadList(data.items);
                renderPagination(data.page, data.total_pages);
                updateStatusInfo(data.total);

            } catch (error) {
                console.error('Load error:', error);
            }
        }

        function renderDownloadList(items) {
            const container = document.getElementById('download-list');

            if (items.length === 0) {
                container.innerHTML = '<div class="empty-list">ë‹¤ìš´ë¡œë“œ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            container.innerHTML = items.map(item => {
                const statusClass = item.status;
                const statusIcon = {
                    'downloading': 'â³',
                    'queued': 'â¸ï¸',
                    'completed': 'âœ…',
                    'error': 'âŒ',
                    'cancelled': 'âšª'
                }[item.status] || 'â“';

                const progressBar = item.status === 'downloading' || item.status === 'queued'
                    ? `<div class="progress-bar">
                         <div class="progress" style="width: ${item.progress}%">
                           <span class="progress-text">${item.progress}%</span>
                         </div>
                       </div>`
                    : '';

                const speedText = item.speed ? formatSpeed(item.speed) : '';
                const sizeText = item.file_size ? formatFileSize(item.file_size) : '';

                const qualityBadge = getQualityBadge(item.quality, item.format_type);

                const actionButtons = getActionButtons(item);

                const thumbnail = item.thumbnail || getYoutubeThumbnail(item.url);

                return `
                    <div class="download-item ${statusClass}" id="item-${item.id}">
                        <div class="item-content">
                            ${thumbnail ? `<img src="${thumbnail}" class="video-thumbnail" onclick="openYoutube('${item.url}')" title="ìœ íŠœë¸Œì—ì„œ ë³´ê¸°" onerror="this.style.display='none'">` : `<div class="video-thumbnail-placeholder" onclick="openYoutube('${item.url}')" title="ìœ íŠœë¸Œì—ì„œ ë³´ê¸°">ğŸ¬</div>`}
                            <div class="item-details">
                                <div class="item-header">
                                    <div class="item-title">
                                        <span class="status-icon">${statusIcon}</span>
                                        <span class="quality-badge">${qualityBadge}</span>
                                        <a href="${item.url}" target="_blank" class="video-link" title="ìœ íŠœë¸Œì—ì„œ ë³´ê¸°">${item.video_title || 'Unknown'}</a>
                                    </div>
                                    <div class="action-buttons">${actionButtons}</div>
                                </div>
                                <div class="item-meta">
                                    ${item.status === 'downloading' ? `<span>ë‹¤ìš´ë¡œë“œ ì¤‘... ${speedText}</span>` : ''}
                                    ${item.status === 'queued' ? `<span>${item.message || 'ëŒ€ê¸° ì¤‘'}</span>` : ''}
                                    ${item.status === 'completed' ? `<span>ì™„ë£Œ ${sizeText}</span>` : ''}
                                    ${item.status === 'error' ? `<span class="error-msg">${item.message || 'ì˜¤ë¥˜ ë°œìƒ'}</span>` : ''}
                                    ${item.status === 'cancelled' ? `<span>ì·¨ì†Œë¨</span>` : ''}
                                    ${item.created_at ? `<span class="date">${formatDate(item.created_at)}</span>` : ''}
                                </div>
                                ${progressBar}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getActionButtons(item) {
            let buttons = '';

            if (item.status === 'completed' && item.filename) {
                buttons += `<button class="download-file-btn" onclick="downloadFile('${item.id}', '${item.type}')">â¬‡ï¸</button>`;
            }

            if (item.status === 'downloading' || item.status === 'queued') {
                buttons += `<button class="cancel-btn" onclick="cancelDownload('${item.id}')">âœ•</button>`;
            }

            if (item.status === 'error') {
                buttons += `<button class="retry-btn" onclick="retryDownload('${item.url}')">ğŸ”„</button>`;
            }

            if (item.status !== 'downloading' && item.status !== 'queued') {
                const deleteWithFile = item.status === 'completed' ? 'true' : 'false';
                buttons += `<button class="delete-btn" onclick="deleteItem('${item.id}', ${deleteWithFile})">ğŸ—‘ï¸</button>`;
            }

            return buttons;
        }

        function getQualityBadge(quality, format_type) {
            if (format_type === 'audio_mp3') return 'ğŸµ MP3';
            if (format_type === 'audio_m4a') return 'ğŸµ M4A';

            const badges = {
                'best': 'â­ Best',
                '2160p': '4K',
                '1440p': '2K',
                '1080p': '1080p',
                '720p': '720p',
                '480p': '480p',
                '360p': '360p'
            };
            return badges[quality] || quality || '-';
        }

        function updateStatusInfo(total) {
            const filterLabels = {
                'all': 'ì „ì²´',
                'active': 'ì§„í–‰ì¤‘',
                'completed': 'ì™„ë£Œ'
            };
            document.getElementById('status-info').textContent =
                `${filterLabels[currentFilter]}: ${total}ê±´`;
        }

        function renderPagination(page, totalPages) {
            const container = document.getElementById('pagination');

            if (totalPages <= 1) {
                container.innerHTML = '';
                return;
            }

            let html = '';
            if (page > 1) {
                html += `<button onclick="goToPage(${page - 1})">â—€ ì´ì „</button>`;
            }
            html += `<span class="page-info">${page} / ${totalPages}</span>`;
            if (page < totalPages) {
                html += `<button onclick="goToPage(${page + 1})">ë‹¤ìŒ â–¶</button>`;
            }

            container.innerHTML = html;
        }

        function goToPage(page) {
            currentPage = page;
            loadDownloads();
        }

        async function startDownload() {
            const url = document.getElementById('url').value.trim();
            const quality = document.getElementById('quality').value;
            const format_type = document.getElementById('format').value;

            if (!url) {
                alert('URLì„ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            const btn = document.querySelector('.input-section button');
            btn.disabled = true;
            btn.textContent = 'ì²˜ë¦¬ ì¤‘...';

            try {
                // ì¤‘ë³µ ì²´í¬
                const dupCheck = await fetch('/api/downloads/check-duplicate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ url: url })
                });
                const dupData = await dupCheck.json();

                if (dupData.duplicate) {
                    const existing = dupData.existing;
                    if (!confirm(`ì´ë¯¸ ë‹¤ìš´ë¡œë“œí•œ ì˜ìƒì…ë‹ˆë‹¤.\n\nì œëª©: ${existing.video_title}\ní’ˆì§ˆ: ${existing.quality}\n\në‹¤ì‹œ ë‹¤ìš´ë¡œë“œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                        btn.disabled = false;
                        btn.textContent = 'ë‹¤ìš´ë¡œë“œ ì‹œì‘';
                        return;
                    }
                }

                // ë‹¤ìš´ë¡œë“œ ì‹œì‘
                const response = await fetch('/download', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ url, quality, format_type })
                });

                const data = await response.json();

                if (response.ok) {
                    document.getElementById('url').value = '';
                    setFilter('all');
                    loadDownloads();
                } else {
                    alert('ì˜¤ë¥˜: ' + data.error);
                }
            } catch (error) {
                alert('ì˜¤ë¥˜: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'ë‹¤ìš´ë¡œë“œ ì‹œì‘';
            }
        }

        async function cancelDownload(itemId) {
            if (!confirm('ë‹¤ìš´ë¡œë“œë¥¼ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

            try {
                await fetch(`/cancel/${itemId}`, { method: 'POST' });
                setTimeout(loadDownloads, 500);
            } catch (error) {
                console.error('Cancel error:', error);
            }
        }

        async function deleteItem(itemId, deleteFile = false) {
            let msg = 'ì´ í•­ëª©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
            if (deleteFile === true || deleteFile === 'true') {
                msg = 'ì´ í•­ëª©ê³¼ íŒŒì¼ì„ í•¨ê»˜ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
            }

            if (!confirm(msg)) return;

            try {
                await fetch(`/api/downloads/${itemId}?delete_file=${deleteFile}`, { method: 'DELETE' });
                loadDownloads();
            } catch (error) {
                console.error('Delete error:', error);
            }
        }

        function downloadFile(itemId, itemType) {
            if (itemType === 'completed') {
                window.location.href = `/download-file-by-history/${itemId}`;
            } else {
                window.location.href = `/download-file/${itemId}`;
            }
        }

        function retryDownload(url) {
            document.getElementById('url').value = url;
            window.scrollTo(0, 0);
        }

        async function cleanupDownloads() {
            if (!confirm('ì‹¤íŒ¨/ì·¨ì†Œëœ í•­ëª©ê³¼ ì„ì‹œ íŒŒì¼ì„ ì •ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

            try {
                const response = await fetch('/api/downloads/cleanup', { method: 'POST' });
                const data = await response.json();
                alert(data.message);
                loadDownloads();
            } catch (error) {
                alert('ì •ë¦¬ ì˜¤ë¥˜: ' + error.message);
            }
        }

        function formatSpeed(bytesPerSecond) {
            if (!bytesPerSecond) return '';
            const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
            let size = bytesPerSecond;
            let unitIndex = 0;
            while (size >= 1024 && unitIndex < units.length - 1) {
                size /= 1024;
                unitIndex++;
            }
            return `${size.toFixed(1)} ${units[unitIndex]}`;
        }

        function formatFileSize(bytes) {
            if (!bytes) return '';
            const units = ['B', 'KB', 'MB', 'GB'];
            let size = bytes;
            let unitIndex = 0;
            while (size >= 1024 && unitIndex < units.length - 1) {
                size /= 1024;
                unitIndex++;
            }
            return `(${size.toFixed(1)} ${units[unitIndex]})`;
        }

        function formatDate(isoString) {
            if (!isoString) return '';
            const date = new Date(isoString);
            return date.toLocaleString('ko-KR', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function getYoutubeThumbnail(url) {
            if (!url) return null;

            // ìœ íŠœë¸Œ ë¹„ë””ì˜¤ ID ì¶”ì¶œ
            let videoId = null;

            // youtube.com/watch?v=VIDEO_ID
            const watchMatch = url.match(/[?&]v=([^&]+)/);
            if (watchMatch) videoId = watchMatch[1];

            // youtu.be/VIDEO_ID
            if (!videoId) {
                const shortMatch = url.match(/youtu\.be\/([^?&]+)/);
                if (shortMatch) videoId = shortMatch[1];
            }

            // youtube.com/embed/VIDEO_ID
            if (!videoId) {
                const embedMatch = url.match(/embed\/([^?&]+)/);
                if (embedMatch) videoId = embedMatch[1];
            }

            // youtube.com/shorts/VIDEO_ID
            if (!videoId) {
                const shortsMatch = url.match(/shorts\/([^?&]+)/);
                if (shortsMatch) videoId = shortsMatch[1];
            }

            if (videoId) {
                return `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`;
            }
            return null;
        }

        // URL ì…ë ¥ì°½ Enter í‚¤
        document.getElementById('url').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') startDownload();
        });

        // ìœ íŠœë¸Œ ì—´ê¸°
        function openYoutube(url) {
            if (url) window.open(url, '_blank');
        }
    </script>
</body>
</html>
